"""
Code generation logic for upb_zig.

Uses Mako templates to generate Zig code from protobuf descriptors.
"""

from mako.template import Template # pyright: ignore[reportMissingTypeStubs]
from google.protobuf.descriptor_pb2 import ( # pyright: ignore[reportMissingModuleSource]
    FileDescriptorProto,
    DescriptorProto,
    FieldDescriptorProto,
    EnumDescriptorProto,
)
from typing import Dict, Optional, List

# -------------- CONSTANTS --------------
# Zig reserved keywords that need escaping with @""
ZIG_KEYWORDS = {
    'addrspace', 'align', 'allowzero', 'and', 'anyframe', 'anytype',
    'asm', 'async', 'await', 'break', 'catch', 'comptime', 'const',
    'continue', 'defer', 'else', 'enum', 'errdefer', 'error', 'export',
    'extern', 'false', 'fn', 'for', 'if', 'inline', 'noalias', 'nosuspend',
    'null', 'opaque', 'or', 'orelse', 'packed', 'pub', 'resume', 'return',
    'linksection', 'struct', 'suspend', 'switch', 'test', 'threadlocal',
    'true', 'try', 'type', 'undefined', 'union', 'unreachable', 'usingnamespace',
    'var', 'volatile', 'while',
}

# Mapping from protobuf field types to Zig types
PROTO_TYPE_TO_ZIG = {
    FieldDescriptorProto.TYPE_DOUBLE: "f64",
    FieldDescriptorProto.TYPE_FLOAT: "f32",
    FieldDescriptorProto.TYPE_INT64: "i64",
    FieldDescriptorProto.TYPE_UINT64: "u64",
    FieldDescriptorProto.TYPE_INT32: "i32",
    FieldDescriptorProto.TYPE_FIXED64: "u64",
    FieldDescriptorProto.TYPE_FIXED32: "u32",
    FieldDescriptorProto.TYPE_BOOL: "bool",
    FieldDescriptorProto.TYPE_STRING: "[]const u8",
    FieldDescriptorProto.TYPE_BYTES: "[]const u8",
    FieldDescriptorProto.TYPE_UINT32: "u32",
    FieldDescriptorProto.TYPE_SFIXED32: "i32",
    FieldDescriptorProto.TYPE_SFIXED64: "i64",
    FieldDescriptorProto.TYPE_SINT32: "i32",
    FieldDescriptorProto.TYPE_SINT64: "i64",
}

# Template for a generated Zig file
ZIG_FILE_TEMPLATE = Template(r'''//! Generated by protoc-gen-zig from ${file_name}
//! DO NOT EDIT - changes will be overwritten
//!
//! This file provides typed Zig bindings over upb for the protobuf
//! definitions in ${file_name}.

const std = @import("std");
const upb_zig = @import("upb_zig");

% for enum in enums:
${generate_enum(enum)}
% endfor

% for message in messages:
${generate_message(message)}
% endfor
''')

# Template for an enum
ENUM_TEMPLATE = Template(r'''/// ${enum.name} enum from ${file_name}
pub const ${enum.name} = enum(i32) {
% for value in enum.value:
    ${escape_zig_keyword(value.name)} = ${value.number},
% endfor

    pub fn fromInt(value: i32) ?${enum.name} {
        return std.meta.intToEnum(${enum.name}, value) catch null;
    }

    pub fn toInt(self: ${enum.name}) i32 {
        return @intFromEnum(self);
    }
};
''')

# Mapping from protobuf field types to runtime getter/setter function names
PROTO_TYPE_TO_RUNTIME_FN = {
    FieldDescriptorProto.TYPE_DOUBLE: "Double",
    FieldDescriptorProto.TYPE_FLOAT: "Float",
    FieldDescriptorProto.TYPE_INT64: "Int64",
    FieldDescriptorProto.TYPE_UINT64: "UInt64",
    FieldDescriptorProto.TYPE_INT32: "Int32",
    FieldDescriptorProto.TYPE_FIXED64: "UInt64",
    FieldDescriptorProto.TYPE_FIXED32: "UInt32",
    FieldDescriptorProto.TYPE_BOOL: "Bool",
    FieldDescriptorProto.TYPE_STRING: "String",
    FieldDescriptorProto.TYPE_BYTES: "String",  # bytes use same API as string
    FieldDescriptorProto.TYPE_UINT32: "UInt32",
    FieldDescriptorProto.TYPE_SFIXED32: "Int32",
    FieldDescriptorProto.TYPE_SFIXED64: "Int64",
    FieldDescriptorProto.TYPE_SINT32: "Int32",
    FieldDescriptorProto.TYPE_SINT64: "Int64",
}

# Template for a message
MESSAGE_TEMPLATE = Template(r'''/// ${message.name} message from ${file_name}
pub const ${message.name} = struct {
    /// Pointer to the underlying upb message
    _msg: *upb_zig.upb_Message,
    /// Arena that owns this message
    _arena: upb_zig.Arena,

    /// MiniTable descriptor for this message type.
    /// Initialized from embedded FileDescriptor on first use.
    pub var minitable: ?*const upb_zig.upb_MiniTable = null;

    /// MessageDef for this message type (needed for JSON encode/decode).
    pub var msgdef: ?*const upb_zig.upb_MessageDef = null;

    /// Field numbers for this message
    pub const FieldNumber = struct {
% for field in message.field:
        pub const ${escape_zig_keyword(field.name)}: u32 = ${field.number};
% endfor
    };

    /// Cached field descriptors - populated on first access
    var fields_initialized: bool = false;
    var fields: [${len(message.field)}]?*const upb_zig.upb_MiniTableField = .{null} ** ${len(message.field)};

    /// Initialize the MiniTable for this message type.
    /// Called automatically when needed; safe to call multiple times.
    pub fn ensureInit() void {
        if (minitable != null) return;
        _file_init();
    }

    fn getField(field_number: u32) ?*const upb_zig.upb_MiniTableField {
        ensureInit();
        const mt = minitable orelse return null;
        return upb_zig.findFieldByNumber(mt, field_number);
    }

    // Nested enums
% for nested_enum in message.enum_type:
    pub const ${nested_enum.name} = enum(i32) {
% for value in nested_enum.value:
        ${escape_zig_keyword(value.name)} = ${value.number},
% endfor

        pub fn fromInt(value: i32) ?${nested_enum.name} {
            return std.meta.intToEnum(${nested_enum.name}, value) catch null;
        }

        pub fn toInt(self: ${nested_enum.name}) i32 {
            return @intFromEnum(self);
        }
    };
% endfor

    // Nested messages (simplified - just type alias for now)
% for nested_msg in message.nested_type:
    pub const ${nested_msg.name} = struct {
        _msg: *upb_zig.upb_Message,
        _arena: upb_zig.Arena,
        pub var minitable: ?*const upb_zig.upb_MiniTable = null;
    };
% endfor

    // Oneofs
% for oneof_name, oneof_fields in oneofs:
    pub const ${pascal_case(oneof_name)}Case = enum {
    % for f in oneof_fields:
        ${escape_zig_keyword(f.name)},
    % endfor
        not_set,
    };

    pub fn ${snake_to_camel(oneof_name)}Case(self: *const ${message.name}) ${pascal_case(oneof_name)}Case {
    % for f in oneof_fields:
        if (getField(FieldNumber.${escape_zig_keyword(f.name)})) |fd| {
            if (upb_zig.hasField(self._msg, fd)) return .${escape_zig_keyword(f.name)};
        }
    % endfor
        return .not_set;
    }
% endfor

% for field in message.field:
    /// ${field.name} field (${field_type_name(field)}, field number ${field.number})
% if is_repeated(field):
    pub fn ${snake_to_camel(field.name)}Count(self: *const ${message.name}) usize {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return 0;
        return upb_zig.getArrayLen(self._msg, field_desc);
    }

  % if is_scalar(field):
    pub fn get${pascal_case(field.name)}(self: *const ${message.name}, index: usize) ${zig_type(field)} {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return ${default_value(field)};
        return ${array_getter_fn(field)}(self._msg, field_desc, index);
    }

    pub fn add${pascal_case(field.name)}(self: *${message.name}, value: ${zig_type(field)}) !void {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return error.OutOfMemory;
        try ${array_appender_fn(field)}(self._msg, field_desc, value, self._arena);
    }
  % elif is_enum(field):
    pub fn get${pascal_case(field.name)}(self: *const ${message.name}, index: usize) ${zig_type(field)} {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return @enumFromInt(0);
        const raw = upb_zig.arrayGetInt32(self._msg, field_desc, index);
        return ${zig_type(field)}.fromInt(raw) orelse @enumFromInt(0);
    }

    pub fn add${pascal_case(field.name)}(self: *${message.name}, value: ${zig_type(field)}) !void {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return error.OutOfMemory;
        try upb_zig.arrayAppendInt32(self._msg, field_desc, value.toInt(), self._arena);
    }
  % else:
    pub fn get${pascal_case(field.name)}(self: *const ${message.name}, index: usize) ?${zig_type(field)} {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return null;
        const sub_msg = upb_zig.arrayGetMessage(self._msg, field_desc, index) orelse return null;
        return ${zig_type(field)}{ ._msg = sub_msg, ._arena = self._arena };
    }

    pub fn add${pascal_case(field.name)}(self: *${message.name}, value: ${zig_type(field)}) !void {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return error.OutOfMemory;
        try upb_zig.arrayAppendMessage(self._msg, field_desc, value._msg, self._arena);
    }
  % endif
% elif is_scalar(field):
    pub fn get${pascal_case(field.name)}(self: *const ${message.name}) ${zig_type(field)} {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return ${default_value(field)};
        return ${runtime_getter(field)}(self._msg, field_desc, ${default_value(field)});
    }

    pub fn set${pascal_case(field.name)}(self: *${message.name}, value: ${zig_type(field)}) void {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return;
        ${runtime_setter(field)}(self._msg, field_desc, value);
    }
% elif is_enum(field):
    pub fn get${pascal_case(field.name)}(self: *const ${message.name}) ${zig_type(field)} {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return @enumFromInt(0);
        const raw = upb_zig.getInt32(self._msg, field_desc, 0);
        return ${zig_type(field)}.fromInt(raw) orelse @enumFromInt(0);
    }

    pub fn set${pascal_case(field.name)}(self: *${message.name}, value: ${zig_type(field)}) void {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return;
        upb_zig.setInt32(self._msg, field_desc, value.toInt());
    }
% else:
    pub fn get${pascal_case(field.name)}(self: *const ${message.name}) ?${zig_type(field)} {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return null;
        const sub_msg = upb_zig.getMessage(self._msg, field_desc) orelse return null;
        return ${zig_type(field)}{ ._msg = sub_msg, ._arena = self._arena };
    }

    pub fn set${pascal_case(field.name)}(self: *${message.name}, value: ${zig_type(field)}) void {
        const field_desc = getField(FieldNumber.${escape_zig_keyword(field.name)}) orelse return;
        upb_zig.setMessage(self._msg, field_desc, value._msg);
    }
% endif

% endfor
    /// Serialize this message to wire format bytes.
    pub fn encode(self: *const ${message.name}) upb_zig.EncodeError![]const u8 {
        ensureInit();
        const mt = minitable orelse return error.EncodeFailed;
        return upb_zig.encode(self._msg, mt, self._arena);
    }

    /// Parse wire format bytes into a new message.
    pub fn decode(arena: upb_zig.Arena, data: []const u8) upb_zig.DecodeError!${message.name} {
        ensureInit();
        const mt = minitable orelse return error.DecodeFailed;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.DecodeFailed;
        try upb_zig.decode(msg, mt, data, arena);
        return ${message.name}{
            ._msg = msg,
            ._arena = arena,
        };
    }

    /// Serialize this message to JSON format.
    pub fn encodeJson(self: *const ${message.name}, options: upb_zig.JsonEncodeOptions) upb_zig.JsonEncodeError![]const u8 {
        ensureInit();
        const md = msgdef orelse return error.JsonEncodeFailed;
        const pool = upb_zig.sharedDefPool() catch return error.JsonEncodeFailed;
        return upb_zig.jsonEncode(self._msg, md, pool, self._arena, options);
    }

    /// Parse JSON into a new message.
    pub fn decodeJson(arena: upb_zig.Arena, json_data: []const u8, options: upb_zig.JsonDecodeOptions) upb_zig.JsonDecodeError!${message.name} {
        ensureInit();
        const mt = minitable orelse return error.JsonDecodeFailed;
        const md = msgdef orelse return error.JsonDecodeFailed;
        const pool = upb_zig.sharedDefPool() catch return error.JsonDecodeFailed;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.JsonDecodeFailed;
        try upb_zig.jsonDecode(msg, md, json_data, pool, arena, options);
        return ${message.name}{
            ._msg = msg,
            ._arena = arena,
        };
    }

    /// Create a new empty message.
    pub fn init(arena: upb_zig.Arena) !${message.name} {
        ensureInit();
        const mt = minitable orelse return error.OutOfMemory;
        const msg = upb_zig.messageNew(mt, arena) orelse return error.OutOfMemory;
        return ${message.name}{
            ._msg = msg,
            ._arena = arena,
        };
    }
};
''')

def serialize_to_zig_bytes(data: bytes) -> str:
    """Convert bytes to a Zig string literal with escape sequences.

    The bytes are embedded as a string literal that can be used as []const u8.
    """
    # Build a string literal with hex escapes for all bytes
    parts: list[str] = []
    for byte in data:
        parts.append(f"\\x{byte:02x}")
    return '"' + ''.join(parts) + '"'


def get_message_full_names(file_desc: FileDescriptorProto) -> List[str]:
    """Get all fully-qualified message names in a file.

    Returns names like "package.MessageName" or "package.Outer.Nested".
    """
    names: list[str] = []
    package = file_desc.package

    def collect_messages(msg: DescriptorProto, prefix: str):
        full_name = f"{prefix}.{msg.name}" if prefix else msg.name
        names.append(full_name)
        for nested in msg.nested_type:
            collect_messages(nested, full_name)

    prefix = package if package else ""
    for msg in file_desc.message_type:
        collect_messages(msg, prefix)

    return names


def proto_to_module_name(file_desc: FileDescriptorProto) -> str:
    """Convert a proto file to its Zig module name.

    Uses file path to ensure uniqueness (multiple files can share a package).
    Example: "google/protobuf/any.proto" -> "google_protobuf_any"
    Example: "foo/bar/baz.proto" -> "foo_bar_baz"
    """
    # Remove .proto extension and replace path separators with underscore
    name = file_desc.name
    if name.endswith(".proto"):
        name = name[:-6]
    return name.replace("/", "_").replace(".", "_")


def escape_zig_keyword(name: str) -> str:
    """Escape a name if it's a Zig keyword."""
    if name in ZIG_KEYWORDS:
        return f'@"{name}"'
    return name

def runtime_getter(field: FieldDescriptorProto) -> str:
    """Get the runtime getter function name for a field type."""
    fn_name = PROTO_TYPE_TO_RUNTIME_FN.get(field.type)
    if fn_name:
        return f"upb_zig.get{fn_name}"
    return None # should these raise


def runtime_setter(field: FieldDescriptorProto) -> str:
    """Get the runtime setter function name for a field type."""
    fn_name = PROTO_TYPE_TO_RUNTIME_FN.get(field.type)
    if fn_name:
        return f"upb_zig.set{fn_name}"
    return None


def array_getter_fn(field: FieldDescriptorProto) -> str:
    """Get the runtime array element getter function name for a field type."""
    fn_name = PROTO_TYPE_TO_RUNTIME_FN.get(field.type)
    if fn_name:
        return f"upb_zig.arrayGet{fn_name}"
    return None


def array_appender_fn(field: FieldDescriptorProto) -> str:
    """Get the runtime array element appender function name for a field type."""
    fn_name = PROTO_TYPE_TO_RUNTIME_FN.get(field.type)
    if fn_name:
        return f"upb_zig.arrayAppend{fn_name}"
    return None


def default_value(field: FieldDescriptorProto) -> str:
    """Get the default value for a field type."""
    match field.type:
        case FieldDescriptorProto.TYPE_STRING | FieldDescriptorProto.TYPE_BYTES:
            return '""'
        case FieldDescriptorProto.TYPE_BOOL:
            return "false"
        case FieldDescriptorProto.TYPE_DOUBLE | FieldDescriptorProto.TYPE_FLOAT:
            return "0.0"
        case _:
            return "0"


def snake_to_camel(name: str) -> str:
    """Convert snake_case to camelCase."""
    parts = name.split('_')
    return parts[0] + ''.join(p.capitalize() for p in parts[1:])


def pascal_case(name: str) -> str:
    """Convert snake_case to PascalCase."""
    return ''.join(p.capitalize() for p in name.split('_'))


def zig_type(field: FieldDescriptorProto) -> str:
    """Get the Zig type for a protobuf field."""
    if field.type == FieldDescriptorProto.TYPE_MESSAGE:
        # Extract message name from type_name (e.g., ".package.MessageName" -> "MessageName")
        return field.type_name.split('.')[-1]
    elif field.type == FieldDescriptorProto.TYPE_ENUM:
        return field.type_name.split('.')[-1]
    else:
        return PROTO_TYPE_TO_ZIG.get(field.type, "anyopaque")


def field_type_name(field: FieldDescriptorProto) -> str:
    """Get a human-readable type name for documentation."""
    type_names = {
        FieldDescriptorProto.TYPE_DOUBLE: "double",
        FieldDescriptorProto.TYPE_FLOAT: "float",
        FieldDescriptorProto.TYPE_INT64: "int64",
        FieldDescriptorProto.TYPE_UINT64: "uint64",
        FieldDescriptorProto.TYPE_INT32: "int32",
        FieldDescriptorProto.TYPE_FIXED64: "fixed64",
        FieldDescriptorProto.TYPE_FIXED32: "fixed32",
        FieldDescriptorProto.TYPE_BOOL: "bool",
        FieldDescriptorProto.TYPE_STRING: "string",
        FieldDescriptorProto.TYPE_BYTES: "bytes",
        FieldDescriptorProto.TYPE_UINT32: "uint32",
        FieldDescriptorProto.TYPE_SFIXED32: "sfixed32",
        FieldDescriptorProto.TYPE_SFIXED64: "sfixed64",
        FieldDescriptorProto.TYPE_SINT32: "sint32",
        FieldDescriptorProto.TYPE_SINT64: "sint64",
        FieldDescriptorProto.TYPE_MESSAGE: "message",
        FieldDescriptorProto.TYPE_ENUM: "enum",
    }
    return type_names.get(field.type, "unknown")


def is_repeated(field: FieldDescriptorProto) -> bool:
    """Check if a field is repeated."""
    return field.label == FieldDescriptorProto.LABEL_REPEATED


def is_scalar(field: FieldDescriptorProto) -> bool:
    """Check if a field is a scalar type (not message, not enum)."""
    return field.type in PROTO_TYPE_TO_RUNTIME_FN


def is_enum(field: FieldDescriptorProto) -> bool:
    """Check if a field is an enum type."""
    return field.type == FieldDescriptorProto.TYPE_ENUM


def default_return(field: FieldDescriptorProto) -> str:
    """Generate default return statement for a field type."""
    if field.type == FieldDescriptorProto.TYPE_STRING:
        return 'return "";'
    elif field.type == FieldDescriptorProto.TYPE_BYTES:
        return 'return "";'
    elif field.type == FieldDescriptorProto.TYPE_BOOL:
        return "return false;"
    elif field.type in (FieldDescriptorProto.TYPE_MESSAGE, FieldDescriptorProto.TYPE_ENUM):
        return "return undefined;"
    else:
        return "return 0;"


def generate_enum(enum: EnumDescriptorProto, file_name: str) -> str:
    """Generate Zig code for an enum."""
    return ENUM_TEMPLATE.render(
        enum=enum,
        file_name=file_name,
        escape_zig_keyword=escape_zig_keyword,
    )


def generate_message(message: DescriptorProto, file_name: str, resolve_type: None = None, parent_fqn: str = "") -> str:
    """Generate Zig code for a message."""
    # Build the fully qualified name for this message
    if parent_fqn:
        message_fqn = f"{parent_fqn}.{message.name}"
    else:
        message_fqn = message.name

    # Collect nested type names for this message
    nested_type_names = set()
    for nested_enum in message.enum_type:
        nested_type_names.add(nested_enum.name)
    for nested_msg in message.nested_type:
        nested_type_names.add(nested_msg.name)

    # Create a zig_type function that uses the resolver if provided
    def zig_type_resolved(field: FieldDescriptorProto) -> str:
        if field.type == FieldDescriptorProto.TYPE_MESSAGE:
            simple_name = field.type_name.split('.')[-1]
            # Check if this is a nested type of the current message
            if simple_name in nested_type_names:
                return simple_name
            if resolve_type:
                return resolve_type(field.type_name)
            return simple_name
        elif field.type == FieldDescriptorProto.TYPE_ENUM:
            simple_name = field.type_name.split('.')[-1]
            # Check if this is a nested enum of the current message
            if simple_name in nested_type_names:
                return simple_name
            if resolve_type:
                return resolve_type(field.type_name)
            return simple_name
        else:
            return PROTO_TYPE_TO_ZIG.get(field.type, "anyopaque")

    # Collect oneofs (skip proto3 synthetic oneofs for optional fields)
    oneofs = []
    for i, oneof in enumerate(message.oneof_decl):
        if oneof.name.startswith('_'):
            continue  # synthetic oneof for proto3 optional
        oneof_fields = [f for f in message.field
                        if f.HasField('oneof_index') and f.oneof_index == i]
        if oneof_fields:
            oneofs.append((oneof.name, oneof_fields))

    return MESSAGE_TEMPLATE.render(
        message=message,
        file_name=file_name,
        len=len,
        snake_to_camel=snake_to_camel,
        pascal_case=pascal_case,
        zig_type=zig_type_resolved,
        field_type_name=field_type_name,
        is_repeated=is_repeated,
        is_scalar=is_scalar,
        is_enum=is_enum,
        default_return=default_return,
        default_value=default_value,
        runtime_getter=runtime_getter,
        runtime_setter=runtime_setter,
        array_getter_fn=array_getter_fn,
        array_appender_fn=array_appender_fn,
        escape_zig_keyword=escape_zig_keyword,
        oneofs=oneofs,
    )


def find_type_file(type_name: str, file_map: Dict[str, FileDescriptorProto]) -> Optional[FileDescriptorProto]:
    """Find which file defines a given type.

    type_name is fully qualified like ".google.protobuf.Any"
    """
    # Remove leading dot
    if type_name.startswith("."):
        type_name = type_name[1:]

    for file_desc in file_map.values():
        pkg = file_desc.package
        # Check enums
        for enum in file_desc.enum_type:
            fqn = f"{pkg}.{enum.name}" if pkg else enum.name
            if fqn == type_name:
                return file_desc
        # Check messages (and nested types)
        for msg in file_desc.message_type:
            fqn = f"{pkg}.{msg.name}" if pkg else msg.name
            if fqn == type_name or type_name.startswith(fqn + "."):
                return file_desc
    return None


def collect_external_types(file_desc: FileDescriptorProto, file_map: Dict[str, FileDescriptorProto]) -> Dict[str, str]:
    """Collect all external type references and their module names.

    Returns a dict mapping type_name -> module_name for types not in this file.
    """
    external_types = {}
    current_package = file_desc.package

    def process_message(msg: DescriptorProto):
        for field in msg.field:
            if field.type in (FieldDescriptorProto.TYPE_MESSAGE, FieldDescriptorProto.TYPE_ENUM):
                type_name = field.type_name
                # Check if this type is external (not in current file)
                type_file = find_type_file(type_name, file_map)
                if type_file and type_file.name != file_desc.name:
                    module_name = proto_to_module_name(type_file)
                    external_types[type_name] = module_name
        # Process nested messages
        for nested in msg.nested_type:
            process_message(nested)

    for msg in file_desc.message_type:
        process_message(msg)

    return external_types


def generate_file(file_desc: FileDescriptorProto, file_map: Dict[str, FileDescriptorProto]) -> str:
    """Generate a complete Zig file from a FileDescriptorProto."""
    # Collect external type references
    external_types = collect_external_types(file_desc, file_map)

    # Get unique module names needed
    modules_needed = sorted(set(external_types.values()))

    # Generate import statements
    imports = ["const std = @import(\"std\");", "const upb_zig = @import(\"upb_zig\");"]
    for module in modules_needed:
        imports.append(f'const {module} = @import("{module}");')

    # Create a type resolver that qualifies external types
    def resolve_type(type_name: str) -> str:
        """Resolve a type name, qualifying with module if external."""
        if type_name in external_types:
            module = external_types[type_name]
            simple_name = type_name.split('.')[-1]
            return f"{module}.{simple_name}"
        else:
            return type_name.split('.')[-1]

    enums_code = [generate_enum(e, file_desc.name) for e in file_desc.enum_type]
    messages_code = [generate_message(m, file_desc.name, resolve_type) for m in file_desc.message_type]

    # Serialize the FileDescriptorProto for embedding
    serialized = file_desc.SerializeToString()
    zig_bytes = serialize_to_zig_bytes(serialized)

    # Get all message full names for initialization
    message_full_names = get_message_full_names(file_desc)

    # Build the message initialization list
    # Maps full name to Zig struct path
    def full_name_to_zig_path(full_name: str) -> str:
        """Convert package.Outer.Inner to Outer.Inner (Zig path)."""
        pkg = file_desc.package
        if pkg and full_name.startswith(pkg + "."):
            return full_name[len(pkg) + 1:]
        return full_name

    # Generate dependency initialization calls
    dep_init_lines = []
    for dep in file_desc.dependency:
        if dep in file_map:
            dep_module = proto_to_module_name(file_map[dep])
            dep_init_lines.append(f'    {dep_module}._file_init();')

    # Generate initialization code for each top-level message (nested are handled separately)
    init_lines = []
    for full_name in message_full_names:
        zig_path = full_name_to_zig_path(full_name)
        # Only initialize top-level messages directly; nested ones need special handling
        if "." not in zig_path:
            init_lines.append(f'    if (pool.findMessage("{full_name}")) |msg_def| {{')
            init_lines.append(f'        {zig_path}.msgdef = msg_def;')
            init_lines.append(f'        {zig_path}.minitable = upb_zig.getMessageMiniTable(msg_def);')
            init_lines.append(f'    }}')

    # Build dependency init section
    dep_init_section = ""
    if dep_init_lines:
        dep_init_section = f'''
    // Initialize dependencies first (they add their descriptors to the shared pool)
{chr(10).join(dep_init_lines)}
'''

    header = f'''//! Generated by protoc-gen-zig from {file_desc.name}
//! DO NOT EDIT - changes will be overwritten
//!
//! This file provides typed Zig bindings over upb for the protobuf
//! definitions in {file_desc.name}.

{chr(10).join(imports)}

// Embedded serialized FileDescriptorProto for this file.
// Used to initialize MiniTables at runtime via upb reflection.
const _file_descriptor_bytes = {zig_bytes};

// Initialization state
var _init_done: bool = false;

/// Initialize all message MiniTables from the embedded descriptor.
/// Called automatically on first use of any message in this file.
/// This function is public so dependencies can call it.
pub fn _file_init() void {{
    if (_init_done) return;
    _init_done = true;
{dep_init_section}
    // Get the shared DefPool and load this file's descriptor
    const pool = upb_zig.sharedDefPool() catch return;
    pool.addFile(_file_descriptor_bytes);

    // Initialize MiniTables for all messages
{chr(10).join(init_lines)}
}}

'''

    return header + "\n".join(enums_code) + "\n" + "\n".join(messages_code)